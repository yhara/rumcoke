; vim: set ft=scheme:
(define util (require "util"))
(define fs (require "fs"))
(define _ (require "underscore"))
(define escodegen (require "escodegen"))

(define Parser (require "./parser"))
(define parser Parser.parser)
(define (symbol? x)
  (instance? x Parser.Symbol))

(define exprs (parser.parse "77"))

(util.puts (util.inspect exprs #f null #t))
(util.puts "--")

(define (raise msg info)
  (or info (set! info {}))
  (aset! info "ERROR" msg)
  (throw (util.inspect info)))
(define (raise-if cond msg info)
  (if cond (raise msg info) undefined))

(define (ast typename info)
  (aset! info "type" typename)
  info)

(define (convert-defvar left rest)
  (define init (if (= rest.length 0)
                 null
                 (if (= rest.length 1)
                   (convert-value (~ rest 0))
                   (raise "malformed defvar" (receiver: receiver)))))
  (ast "VariableDeclaration"
       (kind: "var"
        declarations: (array (ast "VariableDeclarator"
                                  (id: (convert-node left)
                                   init: init))))))

(define (wrap-with-function-call inner-ast)
  (ast "CallExpression"
       (arguments: (array)
        callee: (ast "FunctionExpression"
                     (params: (array)
                      defaults: (array)
                      body: (ast "BlockStatement"
                                 (body: (array (statement-expr inner-ast)))))))))

(define (statement-expr inner-ast)
  (if (.. inner-ast type (match #/Expression$/))
    (ast "ExpressionStatement" (expression: inner-ast))
    inner-ast))

(define (convert-stmt v)
  (statement-expr (convert-node v)))

(define (functoin-with-return params-ary defaults body-exprs)
  (ast "FunctionExpression"
       (params: (_.map params-ary
                       (^(param)
                         (raise-if (not (symbol? param)) "malformed defun param")
                         (convert-node param)))
        defaults: defaults
        body: (ast "BlockStatement"
                   (body: (_.map body-exprs
                                 (^(body-item idx)
                                   (if (= idx (- body-exprs.length 1))
                                     (ast "ReturnStatement"
                                          (argument: (convert-value body-item)))
                                     (convert-stmt body-item)))))))))

(define (convert-defun left rest)
  (define fname (~ left 0))
  (define params (.. left (slice 1)))
  (raise-if (not (symbol? fname)) "malformed defun")
  
  (ast "VariableDeclaration"
    (kind: "var"
     declarations: (array (ast "VariableDeclarator"
                            (id: (convert-node fname)
                             init: (functoin-with-return params (array) rest)))))))

(define syntaxes
  (define: (^(v)
    (define left (~ v 1))
    (define rest (v.slice 2))
    (if (symbol? left)
      (convert-defvar left rest)
      (if (_.isArray left)
        (convert-defun left rest)
        (raise "malformed define" (left: left rest: rest)))))
   "^": (^(v)
    (raise-if (not (_.isArray (~ v 1))) "malformed function literal params")
    (function-with-return (~ v 1) (array) (v.slice 2)))))

#|

(_.each (array "+" "-" "*" "/")
        (^(op)
          (aset! syntaxes op 
                 (^(v) 
                   (ast "BinaryExpression"
                     (operator: op
                      left: (convert-value (~ v 1))
                      right: (convert-value (~ v 2))))))))

#|

(define (convert-value v)
  (convert-node v #t))

(define (convert-node v value-needed?)
  (if (or (_.isNumber v) (_.isString v) (_.isRegExp v)
            (_.isBoolean v) (_.isNull v))
    (ast "Literal" (value: v))
    (if (_.isUndefined v)
      (ast "UnaryExpression"
        (operator: "void" argument: (ast "Literal" (value: 0))))
      (if (_.isEmpty(v))
        ; TODO: Replace this with `(new Object)'
        (ast "ObjectExpression" (properties: (array)))
        (if (symbol? v)
          (ast "Identifier" (name: v.jsName))
          (if (_.isArray v)
            ; Application
            (begin
              (define first (~ v 0))
              (define rest (v.slice 1))
              (define conv (if (symbol? first)
                             (~ syntaxes first.name)
                             #f))
              (if conv
                (conv v value-needed?)
                (ast "CallExpression"
                  (callee: (convert-value (~ v 0))
                   arguments: (rest.map convert-value)))))
            ; Object
            (ast "ObjectExpression" 
              (properties: (_.map (_.pairs v)
                                  (^(pair)
                                    (ast "Property"
                                      (kind: "init"
                                       key: (ast "Identifier"
                                              (name: (~ pair 0)))
                                       value: (convert-value (~ pair 1))))))))))))))

(exprs.forEach (^(expr)
                 (define ast (convert-node expr))
                 ;(util.puts (util.inspect ast #f null #t))
                 (util.puts (escodegen.generate ast))))
|#
