// Generated by RumCoke 0.2.0.dev
var IMAGE_WIDTH = 256;
var IMAGE_HEIGHT = 256;
var NSUBSAMPLES = 2;
var NAO_SAMPLES = 8;
var vec = function (x, y, z) {
    this['x'] = x;
    this['y'] = y;
    this['z'] = z;
    return void 0;
};
var vadd = function (a, b) {
    return new vec(a.x + b.x, a.y + b.y, a.z + b.z);
};
var vsub = function (a, b) {
    return new vec(a.x - b.x, a.y - b.y, a.z - b.z);
};
var vcross = function (a, b) {
    return new vec(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
};
var vdot = function (a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
};
var vlength = function (a) {
    return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
};
var vnormalize = function (a) {
    var len = vlength(a);
    var v = new vec(a.x, a.y, a.z);
    if (Math.abs(len) > 1e-17) {
        v.x = v.x / len;
        v.y = v.y / len;
        v.z = v.z / len;
    }
    return v;
};
var Sphere = function (center, radius) {
    this.center = center;
    this.radius = radius;
    this.intersect = function (ray, isect) {
        var rs = vsub(ray.org, this.center);
        var B = vdot(rs, ray.dir);
        var C = vdot(rs, rs) - this.radius * this.radius;
        var D = B * B - C;
        if (D > 0) {
            var t = -B - Math.sqrt(D);
            if (0 < t && t < isect.t) {
                isect.t = t;
                isect.hit = true;
                isect.p = new vec(ray.org.x + ray.dir.x * t, ray.org.y + ray.dir.y * t, ray.org.z + ray.dir.z * t);
                var n = vsub(isect.p, this.center);
                isect.n = vnormalize(n);
            }
        }
    };
    return false;
};
var Plane = function (p, n) {
    this.p = p;
    this.n = n;
    this.intersect = function (ray, isect) {
        var d = -vdot(this.p, this.n);
        var v = vdot(ray.dir, this.n);
        if (!(Math.abs(v) < 1e-17)) {
            var t = -(vdot(ray.org, n) + d) / v;
            if (0 < t && t < isect.t) {
                isect.hit = true;
                isect.t = t;
                isect.n = this.n;
                isect.p = new vec(ray.org.x + t * ray.dir.x, ray.org.y + t * ray.dir.y, ray.org.z + t * ray.dir.z);
            }
        }
    };
    return false;
};
var Ray = function (org, dir) {
    this.org = org;
    this.dir = dir;
    return false;
};
var Isect = function () {
    this.t = 1000000;
    this.hit = false;
    this.p = new vec(0, 0, 0);
    this.n = new vec(0, 0, 0);
    return false;
};
var clamp = function (f) {
    var i = f * 255.5;
    if (i > 255) {
        i = 255;
    }
    if (i < 0) {
        i = 0;
    }
    return Math.round(i);
};
var orthoBasis = function (basis, n) {
    basis[2] = new vec(n.x, n.y, n.z);
    basis[1] = new vec(0, 0, 0);
    if (-0.6 < n.x && n.x < 0.6)
        basis[1]['x'] = 1;
    else if (-0.6 < n.y && n.y < 0.6)
        basis[1]['y'] = 1;
    else if (-0.6 < n.z && n.z < 0.6)
        basis[1]['z'] = 1;
    else
        basis[1]['x'] = 1;
    basis[0] = vnormalize(vcross(basis[1], basis[2]));
    basis[1] = vnormalize(vcross(basis[2], basis[0]));
    return void 0;
};
var spheres;
var plane;
var init_scene = function () {
    spheres = new Array(3);
    spheres[0] = new Sphere(new vec(-2, 0, -3.5), 0.5);
    spheres[1] = new Sphere(new vec(-0.5, 0, -3), 0.5);
    spheres[2] = new Sphere(new vec(1, 0, -2.2), 0.5);
    return plane = new Plane(new vec(0, -0.5, 0), new vec(0, 1, 0));
};
var ambient_occlusion = function (isect) {
    var basis = new Array(3);
    orthoBasis(basis, isect.n);
    var ntheta = NAO_SAMPLES;
    var nphi = NAO_SAMPLES;
    var eps = 0.0001;
    var occlusion = 0;
    var p = new vec(isect.p.x + eps * isect.n.x, isect.p.y + eps * isect.n.y, isect.p.z + eps * isect.n.z);
    for (j = 0; j < nphi; j++) {
        for (i = 0; i < ntheta; i++) {
            var r = Math.random();
            var phi = 2 * Math.PI * Math.random();
            var x = Math.cos(phi) * Math.sqrt(1 - r);
            var y = Math.sin(phi) * Math.sqrt(1 - r);
            var z = Math.sqrt(r);
            var rx = x * basis[0]['x'] + y * basis[1]['x'] + z * basis[2]['x'];
            var ry = x * basis[0]['y'] + y * basis[1]['y'] + z * basis[2]['y'];
            var rz = x * basis[0]['z'] + y * basis[1]['z'] + z * basis[2]['z'];
            var raydir = new vec(rx, ry, rz);
            var ray = new Ray(p, raydir);
            var occIsect = new Isect();
            spheres[0]['intersect'](ray, occIsect);
            spheres[1]['intersect'](ray, occIsect);
            spheres[2]['intersect'](ray, occIsect);
            plane.intersect(ray, occIsect);
            if (occIsect.hit) {
                occlusion = occlusion + 1;
            }
        }
    }
    occlusion = (ntheta * nphi - occlusion) / (ntheta * nphi);
    return new vec(occlusion, occlusion, occlusion);
};
var render = function (ctx, w, h, nsubsamples) {
    var cnt = 0;
    for (var y = 0; y < h; y++) {
        for (var x = 0; x < w; x++) {
            var rad = new vec(0, 0, 0);
            for (var v = 0; v < nsubsamples; v++) {
                for (var u = 0; u < nsubsamples; u++) {
                    cnt++;
                    var px = (x + u / nsubsamples - w / 2) / (w / 2);
                    var py = -(y + v / nsubsamples - h / 2) / (h / 2);
                    var eye = vnormalize(new vec(px, py, -1));
                    var ray = new Ray(new vec(0, 0, 0), eye);
                    var isect = new Isect();
                    spheres[0].intersect(ray, isect);
                    spheres[1].intersect(ray, isect);
                    spheres[2].intersect(ray, isect);
                    plane.intersect(ray, isect);
                    if (isect.hit) {
                        var col = ambient_occlusion(isect);
                        rad.x = rad.x + col.x;
                        rad.y = rad.y + col.y;
                        rad.z = rad.z + col.z;
                    }
                }
            }
            r = rad.x / (nsubsamples * nsubsamples);
            g = rad.y / (nsubsamples * nsubsamples);
            b = rad.z / (nsubsamples * nsubsamples);
            ctx.push(clamp(r), clamp(g), clamp(b));
        }
    }
};
var main = function () {
    process.stdout.write('P6\n');
    process.stdout.write(IMAGE_WIDTH + ' ' + IMAGE_HEIGHT + '\n');
    process.stdout.write('255\n');
    var buf = [];
    var elapsed = 0;
    var start = new Date();
    init_scene();
    render(buf, IMAGE_WIDTH, IMAGE_HEIGHT, 1);
    elapsed = new Date() - start;
    process.stderr.write('Time: ' + elapsed / 1000 + '\n');
    var buffer = new Buffer(buf.length);
    for (var i = 0; i < buf.length; i++) {
        buffer.writeUInt8(buf[i], i);
    }
    return process.stdout.write(buffer);
};
main()
