; vim: set ft=scheme:
(define util (require "util"))
(define fs (require "fs"))
(define _ (require "underscore"))
(define escodegen (require "escodegen"))

(define Parser (require "./parser"))
(define parser Parser.parser)
(define Sym Parser.Sym)
(define (symbol? x)
  (instance? x Parser.Symbol))

(define (d x)
  (util.puts "debug: " (util.inspect x #f null #t)))
  ; util.inspect obj showHidden depth colors

;(define exprs (parser.parse (fs.readFileSync (~ process.argv 2) "utf8")))

;(util.puts (util.inspect exprs #f null #t))
;(util.puts "--")

(define (raise msg info)
  (or info (set! info {}))
  (aset! info "ERROR" msg)
  (throw (util.inspect info)))
(define (raise-if cond msg info)
  (if cond (raise msg info) undefined))

(define (ast typename info)
  (aset! info "type" typename)
  info)

(define (convert-defvar left rest)
  (define init (if (= rest.length 0)
                 null
                 (if (= rest.length 1)
                   (convert-value (~ rest 0))
                   (raise "malformed defvar" (receiver: receiver)))))
  (ast "VariableDeclaration"
       (kind: "var"
        declarations: (array (ast "VariableDeclarator"
                                  (id: (convert-node left)
                                   init: init))))))

(define (wrap-with-function-call inner-ast)
  (ast "CallExpression"
       (arguments: (array)
        callee: (ast "FunctionExpression"
                     (params: (array)
                      defaults: (array)
                      body: (ast "BlockStatement"
                                 (body: (array (statement-expr inner-ast)))))))))

(define (statement-expr inner-ast)
  (if (.. inner-ast type (match #/Literal|Expression$/))
    (ast "ExpressionStatement" (expression: inner-ast))
    inner-ast))

(define (convert-stmt v)
  (statement-expr (convert-node v)))

(define (block-stmt-with-return body-exprs)
  (ast "BlockStatement"
    (body: (body-exprs.map (^(body-item idx)
                             (if (= idx (- body-exprs.length 1))
                               (ast "ReturnStatement"
                                 (argument: (convert-value body-item)))
                               (convert-stmt body-item)))))))

(define (function-with-return params-ary defaults body-exprs)
  (ast "FunctionExpression"
       (params: (_.map params-ary
                       (^(param)
                         (raise-if (not (symbol? param)) "malformed defun param")
                         (convert-node param)))
        defaults: defaults
        body: (block-stmt-with-return body-exprs))))

(define (convert-defun left rest)
  (define fname (~ left 0))
  (define params (left.slice 1))
  (raise-if (not (symbol? fname)) "malformed defun")
  
  (ast "VariableDeclaration"
    (kind: "var"
     declarations: (array (ast "VariableDeclarator"
                            (id: (convert-node fname)
                             init: (function-with-return params (array) rest)))))))

(define syntaxes
  ("define": (^(v)
    (define left (~ v 1))
    (define rest (v.slice 2))
    (if (symbol? left)
      (convert-defvar left rest)
      (if (_.array? left)
        (convert-defun left rest)
        (raise "malformed define" (left: left rest: rest)))))
   "^": (^(v)
    (raise-if (not (_.array? (~ v 1))) "malformed function literal params")
    (function-with-return (~ v 1) (array) (v.slice 2)))

   "..": (^(v)
    (define receiver (~ v 1))
    (define call-specs (v.slice 2))
    (call-specs.reduce (^(acc call-spec)
      (if (symbol? call-spec)
        (ast "MemberExpression"
          (computed: #f
           object: acc
           property: (convert-node call-spec)))
        (if (_.array? call-spec)
          (begin
            (raise-if (not (symbol? (~ call-spec 0)))
                      "malformed .."
                      (expected: "Symbol" given: (~ call-spec 0)))
            (ast "CallExpression"
              (callee: (ast "MemberExpression"
                         (computed: #f
                          object: acc
                          property: (convert-node (~ call-spec 0))))
               arguments: (_.map (call-spec.slice 1) convert-value))))
          (raise "malformed ..")))
      )
      (convert-value receiver)))

   "instance?": (^(v)
     (ast "BinaryExpression"
       (operator: "instanceof"
        left: (convert-value (~ v 1))
        right: (convert-value (~ v 2)))))

   "set!": (^(v)
     (ast "AssignmentExpression"
       (operator: "="
        left: (convert-value (~ v 1))
        right: (convert-value (~ v 2)))))

   "aset!": (^(v)
     (ast "AssignmentExpression"
       (operator: "="
        left: (ast "MemberExpression"
                (computed: #t
                 object: (convert-value (~ v 1))
                 property: (convert-value (~ v 2))))
        right: (convert-value (~ v 3)))))

   "~": (^(v)
    (raise-if (not (= v.length 3)) "mailformed ~")
    (ast "MemberExpression"
      (computed: #t
       object: (convert-value (~ v 1))
       property: (convert-value (~ v 2)))))

   "array": (^(v)
     (ast "ArrayExpression"
       (elements: (_.map (v.slice 1) convert-value))))

   "=": (^(v)
     (raise-if (not (= v.length 3)) "malformed =")
     (ast "BinaryExpression"
       (operator: "==="
        left: (convert-value (~ v 1))
        right: (convert-value (~ v 2)))))

   "if": (^(v value-needed?)
     (if value-needed?
       (ast "ConditionalExpression"
         (test: (convert-value (~ v 1))
          consequent: (convert-value (~ v 2))
          alternate: (convert-value (~ v 3))))
       (if (_.undefined? (~ v 3))
         (ast "IfStatement"
           (test: (convert-value (~ v 1))
            consequent: (convert-stmt (~ v 2))))
         (ast "IfStatement"
           (test: (convert-value (~ v 1))
            consequent: (convert-stmt (~ v 2))
            alternate: (convert-stmt (~ v 3)))))))

   "begin": (^(v value-needed?)
     (if value-needed?
       (ast "CallExpression"
         (arguments: (array)
          callee: (ast "FunctionExpression"
                    (params: (array)
                     defaults: (array)
                     body: (block-stmt-with-return (v.slice 1))))))
       (ast "BlockStatement"
         (body: (_.map (v.slice 1) convert-stmt)))))

   "and": (^(v)
     (ast "BinaryExpression"
       (operator: "&&"
        left: (convert-value (~ v 1))
        right: (convert-value (~ v 2)))))

   "or": (^(v)
     (define rest (v.slice 1))
     (if (= rest.length 0)
       (ast "Literal" (value: #f))
       (if (= rest.length 1)
         (ast "LogicalExpression"
           (operator: "||"
            left: (convert-value (~ rest 0))
            right: (ast "Literal" (value: #f))))
         (_.reduce (rest.slice 1)
                   (^(acc item)
                     (ast "LogicalExpression"
                          (operator: "||"
                                     left: acc
                                     right: (convert-value item))))
                   (convert-value (~ rest 0))))))

   "not": (^(v)
     (raise-if (not (= v.length 2)) "malformed not")
     (ast "UnaryExpression"
       (operator: "!"
        argument: (convert-value (~ v 1)))))

   "throw": (^(v value-needed?)
     (raise-if (not (= v.length 2)) "malformed throw")
     (define throw-stmt (ast "ThrowStatement"
                          (argument: (convert-value (~ v 1)))))
     (if value-needed?
       (wrap-with-function-call throw-stmt)
       throw-stmt))
   ))

(_.each (array "+" "-" "*" "/")
        (^(op)
          (aset! syntaxes op 
                 (^(v) 
                   (ast "BinaryExpression"
                     (operator: op
                      left: (convert-value (~ v 1))
                      right: (convert-value (~ v 2))))))))

(define (convert-value v)
  (convert-node v #t))

(define (convert-node v value-needed?)
  (if (or (_.number? v) (_.string? v) (_.reg-exp? v)
          (_.boolean? v) (_.null? v))
    (ast "Literal" (value: v))
    (if (_.undefined? v)
      (ast "UnaryExpression"
        (operator: "void"
         argument: (ast "Literal" (value: 0))))
      (if (_.empty? v)
        ; TODO: Replace this with `(new Object)'
        (ast "ObjectExpression" (properties: (array)))
        (if (symbol? v)
          (ast "Identifier" (name: v.jsName))
          (if (_.array? v)
            ; Application
            (begin
              (define first (~ v 0))
              (define rest (v.slice 1))
              (define conv (if (symbol? first)
                             (~ syntaxes first.name)
                             #f))
              (if conv
                (conv v value-needed?)
                (ast "CallExpression"
                  (callee: (convert-value (~ v 0))
                   arguments: (rest.map convert-value)))))
            ; Object
            (ast "ObjectExpression" 
              (properties: (_.map (_.pairs v)
                                  (^(pair)
                                    (ast "Property"
                                      (kind: "init"
                                       key: (ast "Literal"
                                              (value: (~ pair 0)))
                                       value: (convert-value (~ pair 1))))))))))))))

; Macro
(define macros 
  ("when": (^(v)
    (array (Sym "if") (~ v 1)
             (.. (array (Sym "begin")) (concat (v.slice 2)))
             undefined))))
   
(define (expand-macros v mod)
  (or mod (set! mod {}))
  (if (_.array? v)
    (begin
      (define s (~ v 0))
      (if (symbol? s)
        (if (~ syntaxes s.name)
          ; Special forms
          ; TODO: expand macro for each form
          v
          (begin
            (define macro (~ macros s.name))
            (if macro
              (begin ; Found macro usage
                (aset! mod "modified" #t)
                ; TODO: recursive
                (macro v))
              ; Normal funcall
              (v.map (^(x) (expand-macros x mod))))))
        ; Computed funcall
        (v.map (^(x) (expand-macros x mod)))))
    ; Literal
    v))

(define (translate exprs)
  (util.puts "// Generated by RumCoke v0.0.2.dev")
  (exprs.forEach (^(expr)
                   (define expanded (expand-macros expr))
                   ;(d expanded)
                   (define ast (convert-node expanded))
                   ;(util.puts (+ "ast: " (util.inspect ast #f null #t)))
                   (util.puts (escodegen.generate ast)))))

(aset! module.exports "translate" translate)
