// Generated by RumCoke 0.2.0.dev
var util = require('util');
var fs = require('fs');
var _ = require('underscore');
var escodegen = require('escodegen');
var RUM_VERSION = require('./version');
var Parser = require('./parser');
var parser = Parser.parser;
var RumExpr = require('./rum_expr');
var Sym = RumExpr.Sym;
var isSymbol = RumExpr.isSymbol;
var isObjExpr = RumExpr.isObjExpr;
var d = function (arg1, arg2) {
    var header = arg2 ? arg1 : 'debug: ';
    var value = arg2 || arg1;
    util.puts(header, util.inspect(value, false, null, true));
    return value;
};
var raise = function (msg, info) {
    info || (info = new Object());
    info['ERROR'] = msg;
    throw util.inspect(info);
};
var raiseIf = function (cond, msg, info) {
    return cond ? function () {
        return raise(msg, info);
    }() : void 0;
};
var append = function () {
    return _.flatten(arguments, true);
};
var flatMap = function (ls, f) {
    return _.flatten(_.map(ls, f), true);
};
var cons = function (obj, ary) {
    return append([obj], ary);
};
var ast = function (typename, info) {
    info['type'] = typename;
    return info;
};
var convertDefvar = function (left, rest) {
    var init = rest.length === 0 ? null : rest.length === 1 ? convertValue(rest[0]) : raise('malformed defvar', {'receiver': receiver});
    return ast('VariableDeclaration', {
        'kind': 'var',
        'declarations': [ast('VariableDeclarator', {
                'id': convertNode(left),
                'init': init
            })]
    });
};
var wrapWithFunctionCall = function (innerAst) {
    return ast('CallExpression', {
        'arguments': [],
        'callee': ast('FunctionExpression', {
            'params': [],
            'defaults': [],
            'body': ast('BlockStatement', {'body': [statementExpr(innerAst)]}),
            'id': null,
            'rest': null,
            'generator': false,
            'expression': false
        })
    });
};
var statementExpr = function (innerAst) {
    return innerAst.type.match(/Literal|Expression|Identifier$/) ? ast('ExpressionStatement', {'expression': innerAst}) : innerAst;
};
var convertStmt = function (v) {
    return statementExpr(convertNode(v));
};
var convertStmts = function (vs) {
    return _.map(vs, convertStmt);
};
var blockStmtWithReturn = function (bodyExprs) {
    return ast('BlockStatement', {'body': bodyExprs.map(function (bodyItem, idx) {
            return idx === bodyExprs.length - 1 ? function () {
                var novalAst = convertNode(bodyItem);
                return novalAst.type.match(/ForStatement|ThrowStatement|WhileStatement/) ? novalAst : ast('ReturnStatement', {'argument': convertValue(bodyItem)});
            }() : convertStmt(bodyItem);
        })});
};
var functionWithReturn = function (paramsAry, defaults, bodyExprs) {
    return ast('FunctionExpression', {
        'params': _.map(paramsAry, function (param) {
            raiseIf(!isSymbol(param), 'malformed defun param');
            return convertNode(param);
        }),
        'defaults': defaults,
        'body': blockStmtWithReturn(bodyExprs),
        'id': null,
        'rest': null,
        'generator': false,
        'expression': false
    });
};
var convertDefun = function (left, rest) {
    var fname = left[0];
    var params = left.slice(1);
    raiseIf(!isSymbol(fname), 'malformed defun');
    return ast('VariableDeclaration', {
        'kind': 'var',
        'declarations': [ast('VariableDeclarator', {
                'id': convertNode(fname),
                'init': functionWithReturn(params, [], rest)
            })]
    });
};
var syntaxes = {
        'define': function (v) {
            var left = v[1];
            var rest = v.slice(2);
            return isSymbol(left) ? convertDefvar(left, rest) : _.isArray(left) ? convertDefun(left, rest) : raise('malformed define', {
                'left': left,
                'rest': rest
            });
        },
        '^': function (v) {
            raiseIf(!_.isArray(v[1]), 'malformed function literal params');
            return functionWithReturn(v[1], [], v.slice(2));
        },
        '..': function (v) {
            var receiver = v[1];
            var callSpecs = v.slice(2);
            return callSpecs.reduce(function (acc, callSpec) {
                return isSymbol(callSpec) ? ast('MemberExpression', {
                    'computed': false,
                    'object': acc,
                    'property': convertNode(callSpec)
                }) : _.isArray(callSpec) ? function () {
                    raiseIf(!isSymbol(callSpec[0]), 'malformed ..', {
                        'expected': 'Symbol',
                        'given': callSpec[0]
                    });
                    return ast('CallExpression', {
                        'callee': ast('MemberExpression', {
                            'computed': false,
                            'object': acc,
                            'property': convertNode(callSpec[0])
                        }),
                        'arguments': _.map(callSpec.slice(1), convertValue)
                    });
                }() : raise('malformed ..');
            }, convertValue(receiver));
        },
        'set!': function (v) {
            return ast('AssignmentExpression', {
                'operator': '=',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'aset!': function (v) {
            return ast('AssignmentExpression', {
                'operator': '=',
                'left': ast('MemberExpression', {
                    'computed': true,
                    'object': convertValue(v[1]),
                    'property': convertValue(v[2])
                }),
                'right': convertValue(v[3])
            });
        },
        '~': function (v) {
            raiseIf(v.length < 3, {
                'msg': 'mailformed ~',
                'v': v
            });
            return _.reduce(v.slice(2), function (a, b) {
                return ast('MemberExpression', {
                    'computed': true,
                    'object': a,
                    'property': convertValue(b)
                });
            }, convertValue(v[1]));
        },
        'new': function (v) {
            return ast('NewExpression', {
                'callee': convertValue(v[1]),
                'arguments': _.map(v.slice(2), convertValue)
            });
        },
        'array': function (v) {
            return ast('ArrayExpression', {'elements': _.map(v.slice(1), convertValue)});
        },
        '=': function (v) {
            raiseIf(!(v.length === 3), 'malformed =');
            return ast('BinaryExpression', {
                'operator': '===',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'if': function (v, isValueNeeded) {
            return isValueNeeded ? ast('ConditionalExpression', {
                'test': convertValue(v[1]),
                'consequent': convertValue(v[2]),
                'alternate': convertValue(v[3])
            }) : _.isUndefined(v[3]) ? ast('IfStatement', {
                'test': convertValue(v[1]),
                'consequent': convertStmt(v[2])
            }) : ast('IfStatement', {
                'test': convertValue(v[1]),
                'consequent': convertStmt(v[2]),
                'alternate': convertStmt(v[3])
            });
        },
        'case': function (v, isValueNeeded) {
            return ast('SwitchStatement', {
                'discriminant': convertValue(v[1]),
                'cases': flatMap(v.slice(2), function (clause) {
                    var cases = clause[0];
                    return Sym('else') === cases ? ast('SwitchCase', {
                        'test': null,
                        'consequent': convertStmts(clause.slice(1))
                    }) : function () {
                        var lastTest = cases.pop();
                        var body = clause.slice(1);
                        return append(_.map(cases, function (test) {
                            return ast('SwitchCase', {
                                'test': convertValue(test),
                                'consequent': []
                            });
                        }), [ast('SwitchCase', {
                                'test': convertValue(lastTest),
                                'consequent': append(convertStmts(body), ast('BreakStatement', {'label': null}))
                            })]);
                    }();
                })
            });
        },
        'begin': function (v, isValueNeeded) {
            return isValueNeeded ? ast('CallExpression', {
                'arguments': [],
                'callee': ast('FunctionExpression', {
                    'params': [],
                    'defaults': [],
                    'body': blockStmtWithReturn(v.slice(1)),
                    'id': null,
                    'rest': null,
                    'generator': false,
                    'expression': false
                })
            }) : ast('BlockStatement', {'body': _.map(v.slice(1), convertStmt)});
        },
        'and': function (v) {
            return ast('LogicalExpression', {
                'operator': '&&',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'or': function (v) {
            var rest = v.slice(1);
            return rest.length === 0 ? ast('Literal', {'value': false}) : rest.length === 1 ? ast('LogicalExpression', {
                'operator': '||',
                'left': convertValue(rest[0]),
                'right': ast('Literal', {'value': false})
            }) : _.reduce(rest.slice(1), function (acc, item) {
                return ast('LogicalExpression', {
                    'operator': '||',
                    'left': acc,
                    'right': convertValue(item)
                });
            }, convertValue(rest[0]));
        },
        'not': function (v) {
            raiseIf(!(v.length === 2), 'malformed not');
            return ast('UnaryExpression', {
                'operator': '!',
                'argument': convertValue(v[1])
            });
        },
        'while': function (v, isValueNeeded) {
            var whileStmt = ast('WhileStatement', {
                    'test': convertValue(v[1]),
                    'body': ast('BlockStatement', {'body': _.map(v.slice(2), convertStmt)})
                });
            return isValueNeeded ? wrapWithFunctionCall(whileStmt) : whileStmt;
        },
        'for': function (v) {
            raiseIf(v.length < 4, {
                'msg': 'malformed for',
                'v': v
            });
            return ast('ForStatement', {
                'init': convertNode(v[1]),
                'test': convertValue(v[2]),
                'update': convertNode(v[3]),
                'body': ast('BlockStatement', {'body': convertStmts(v.slice(4))})
            });
        },
        'break': function (v) {
            return ast('BreakStatement', {'label': null});
        },
        'throw': function (v) {
            raiseIf(!(v.length === 2), 'malformed throw');
            return ast('ThrowStatement', {'argument': convertValue(v[1])});
        },
        'instance?': function (v) {
            raiseIf(!(v.length === 3), 'malformed instance?');
            return ast('BinaryExpression', {
                'operator': 'instanceof',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'inc!': function (v) {
            raiseIf(!(v.length === 2), {
                'msg': 'malformed inc!',
                'v': v
            });
            return ast('UpdateExpression', {
                'operator': '++',
                'argument': convertValue(v[1]),
                'prefix': false
            });
        },
        'dec!': function (v) {
            raiseIf(!(v.length === 2), {
                'msg': 'malformed dec!',
                'v': v
            });
            return ast('UpdateExpression', {
                'operator': '--',
                'argument': convertValue(v[1]),
                'prefix': false
            });
        },
        'raw-js-ast': function (v) {
            raiseIf(!(v.length === 2), 'malformed raw-js-ast');
            var arg = v[1];
            return isObjExpr(arg) ? arg['content'] : arg;
        }
    };
_.each([
    '+',
    '-',
    '*',
    '/'
], function (op) {
    return syntaxes[op] = function (v) {
        return _.reduce(_.map(v.slice(1), convertValue), function (a, b) {
            return ast('BinaryExpression', {
                'operator': op,
                'left': a,
                'right': b
            });
        });
    };
})
_.each([
    '<',
    '<=',
    '>',
    '>='
], function (op) {
    return syntaxes[op] = function (v) {
        var l = _.initial(v.slice(1));
        var r = v.slice(2);
        var binaryExpr = function (pair) {
            return ast('BinaryExpression', {
                'operator': op,
                'left': convertValue(pair[0]),
                'right': convertValue(pair[1])
            });
        };
        return _.reduce(_.map(_.zip(l, r), binaryExpr), function (a, b) {
            return ast('LogicalExpression', {
                'operator': '&&',
                'left': a,
                'right': b
            });
        });
    };
})
var convertNode = function (v, isValueNeeded) {
    return _.isNumber(v) || _.isString(v) || _.isRegExp(v) || _.isBoolean(v) || _.isNull(v) ? ast('Literal', {'value': v}) : _.isUndefined(v) ? ast('UnaryExpression', {
        'operator': 'void',
        'argument': ast('Literal', {'value': 0})
    }) : _.isEmpty(v) ? ast('ObjectExpression', {'properties': []}) : isSymbol(v) ? ast('Identifier', {'name': v.jsName}) : _.isArray(v) ? function () {
        var first = v[0];
        var rest = v.slice(1);
        var conv = isSymbol(first) && syntaxes[first.name];
        return conv ? conv(v, isValueNeeded) : ast('CallExpression', {
            'callee': convertValue(v[0]),
            'arguments': rest.map(convertValue)
        });
    }() : isObjExpr(v) ? ast('ObjectExpression', {'properties': _.map(_.pairs(v.content), function (pair) {
            return ast('Property', {
                'kind': 'init',
                'key': ast('Literal', {'value': pair[0]}),
                'value': convertValue(pair[1])
            });
        })}) : raise('Misplaced JS object', {'js_object': v});
};
var convertValue = function (v) {
    return convertNode(v, true);
};
var expandQq = function (a) {
    return !_.isArray(a) ? a : cons(Sym('append'), a.map(function (x) {
        return _.isArray(x) ? x[0] === Sym('quasiquote') ? raise('Nested quasiquote is not supported yet') : x[0] === Sym('unquote') ? append([Sym('array')], [x[1]]) : x[0] === Sym('unquote-splicing') ? x[1] : append([Sym('array')], [expandQq(x)]) : isSymbol(x) ? append([Sym('array')], [append([Sym('quote')], [x])]) : append([Sym('array')], [x]);
    }));
};
var _quote = function (a) {
    return isSymbol(a) ? [
        Sym('Sym'),
        a.name
    ] : _.isArray(a) ? cons(Sym('array'), a.map(_quote)) : a;
};
var macros = {
        'quote': function (v) {
            raiseIf(!(v.length === 2), 'malformed quote');
            return _quote(v[1]);
        },
        'cond': function (v) {
            raiseIf(v.length === 1, 'at least one clause is required for cond');
            var clauses = v.slice(1);
            return _.reduceRight(clauses, function (ret, clause) {
                raiseIf(!_.isArray(clause), 'bad clause in cond', {'clause': clause});
                return _.isUndefined(ret) && clause[0] === Sym('else') ? clause.length === 2 ? clause[1] : append([Sym('begin')], clause.slice(1)) : function () {
                    var test = clause[0];
                    var body = clause.slice(1);
                    return body.length === 1 ? append([Sym('if')], [test], [body[0]], [ret]) : append([Sym('if')], [test], [append([Sym('begin')], body)], [ret]);
                }();
            }, void 0);
        },
        'when': function (v) {
            return append([Sym('if')], [v[1]], [append([Sym('begin')], v.slice(2))], [void 0]);
        },
        'unless': function (v) {
            return append([Sym('if')], [v[1]], [void 0], [append([Sym('begin')], v.slice(2))]);
        },
        'quasiquote': function (v) {
            raiseIf(!(v.length === 2), 'malformed quasiquote');
            return expandQq(v[1]);
        }
    };
var expandMacros = function (v, mod) {
    mod || (mod = new Object());
    var expandInner = function (x) {
        return expandMacros(x, mod);
    };
    return _.isArray(v) ? function () {
        var car = v[0];
        return isSymbol(car) ? syntaxes[car.name] ? _.contains([
            Sym('define'),
            Sym('^'),
            Sym('set!'),
            Sym('aset!')
        ], car) ? append(v.slice(0, 2), _.map(v.slice(2), expandInner)) : _.contains([
            Sym('throw'),
            Sym('not'),
            Sym('and'),
            Sym('or'),
            Sym('~'),
            Sym('new'),
            Sym('array'),
            Sym('='),
            Sym('if'),
            Sym('begin'),
            Sym('while')
        ], car) ? v.map(expandInner) : Sym('..') === car ? append([
            Sym('..'),
            expandMacros(v[1], mod)
        ], _.map(v.slice(2), function (c) {
            return isSymbol(c) ? expandMacros(c, mod) : _.isArray(c) ? cons(c[0], _.map(c.slice(1), expandInner)) : raise('malformed ..');
        })) : v : function () {
            var macro = macros[car.name];
            return macro ? function () {
                mod['modified'] = true;
                var ret = macro(v);
                while (true) {
                    var _mod = new Object();
                    ret = expandMacros(ret, _mod);
                    if (!_mod.modified) {
                        break;
                    }
                }
                return ret;
            }() : v.map(expandInner);
        }() : v.map(expandInner);
    }() : isObjExpr(v) ? function () {
        var ret = new Object();
        _.each(v.content, function (value, key) {
            return ret[key] = expandMacros(value);
        });
        return new RumExpr.ObjExpr(ret);
    }() : v;
};
var translateExpr = function (expr) {
    var expanded = expandMacros(expr);
    return convertNode(expanded);
};
var translate = function (exprs, _putter) {
    var ret = '';
    var putter = _putter || function (s) {
            return ret = ret + '\n' + s;
        };
    putter('// Generated by RumCoke ' + RUM_VERSION);
    exprs.forEach(function (expr) {
        var ast = translateExpr(expr);
        return putter(escodegen.generate(ast));
    });
    return putter ? void 0 : ret;
};
module.exports['translate'] = translate
module.exports['translateExpr'] = translateExpr
module.exports['expandMacros'] = expandMacros
