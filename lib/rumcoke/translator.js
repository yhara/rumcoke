// Generated by RumCoke 0.2.0.dev
var util = require('util');
var fs = require('fs');
var _ = require('underscore');
var escodegen = require('escodegen');
var RUM_VERSION = require('./version');
var Parser = require('./parser');
var parser = Parser.parser;
var Sym = Parser.Sym;
var isSymbol = Parser.isSymbol;
var d = function (x) {
    return util.puts('debug: ', util.inspect(x, false, null, true));
};
var raise = function (msg, info) {
    info || (info = new Object());
    info['ERROR'] = msg;
    return function () {
        throw util.inspect(info);
    }();
};
var raiseIf = function (cond, msg, info) {
    return cond ? function () {
        return raise(msg, info);
    }() : void 0;
};
var append = function (ary1, ary2) {
    return ary1.concat(ary2);
};
var cons = function (obj, ary) {
    return append([obj], ary);
};
var ast = function (typename, info) {
    info['type'] = typename;
    return info;
};
var convertDefvar = function (left, rest) {
    var init = rest.length === 0 ? null : rest.length === 1 ? convertValue(rest[0]) : raise('malformed defvar', {'receiver': receiver});
    return ast('VariableDeclaration', {
        'kind': 'var',
        'declarations': [ast('VariableDeclarator', {
                'id': convertNode(left),
                'init': init
            })]
    });
};
var wrapWithFunctionCall = function (innerAst) {
    return ast('CallExpression', {
        'arguments': [],
        'callee': ast('FunctionExpression', {
            'params': [],
            'defaults': [],
            'body': ast('BlockStatement', {'body': [statementExpr(innerAst)]}),
            'id': null,
            'rest': null,
            'generator': false,
            'expression': false
        })
    });
};
var statementExpr = function (innerAst) {
    return innerAst.type.match(/Literal|Expression$/) ? ast('ExpressionStatement', {'expression': innerAst}) : innerAst;
};
var convertStmt = function (v) {
    return statementExpr(convertNode(v));
};
var blockStmtWithReturn = function (bodyExprs) {
    return ast('BlockStatement', {'body': bodyExprs.map(function (bodyItem, idx) {
            return idx === bodyExprs.length - 1 ? ast('ReturnStatement', {'argument': convertValue(bodyItem)}) : convertStmt(bodyItem);
        })});
};
var functionWithReturn = function (paramsAry, defaults, bodyExprs) {
    return ast('FunctionExpression', {
        'params': _.map(paramsAry, function (param) {
            raiseIf(!isSymbol(param), 'malformed defun param');
            return convertNode(param);
        }),
        'defaults': defaults,
        'body': blockStmtWithReturn(bodyExprs),
        'id': null,
        'rest': null,
        'generator': false,
        'expression': false
    });
};
var convertDefun = function (left, rest) {
    var fname = left[0];
    var params = left.slice(1);
    raiseIf(!isSymbol(fname), 'malformed defun');
    return ast('VariableDeclaration', {
        'kind': 'var',
        'declarations': [ast('VariableDeclarator', {
                'id': convertNode(fname),
                'init': functionWithReturn(params, [], rest)
            })]
    });
};
var syntaxes = {
        'define': function (v) {
            var left = v[1];
            var rest = v.slice(2);
            return isSymbol(left) ? convertDefvar(left, rest) : _.isArray(left) ? convertDefun(left, rest) : raise('malformed define', {
                'left': left,
                'rest': rest
            });
        },
        '^': function (v) {
            raiseIf(!_.isArray(v[1]), 'malformed function literal params');
            return functionWithReturn(v[1], [], v.slice(2));
        },
        '..': function (v) {
            var receiver = v[1];
            var callSpecs = v.slice(2);
            return callSpecs.reduce(function (acc, callSpec) {
                return isSymbol(callSpec) ? ast('MemberExpression', {
                    'computed': false,
                    'object': acc,
                    'property': convertNode(callSpec)
                }) : _.isArray(callSpec) ? function () {
                    raiseIf(!isSymbol(callSpec[0]), 'malformed ..', {
                        'expected': 'Symbol',
                        'given': callSpec[0]
                    });
                    return ast('CallExpression', {
                        'callee': ast('MemberExpression', {
                            'computed': false,
                            'object': acc,
                            'property': convertNode(callSpec[0])
                        }),
                        'arguments': _.map(callSpec.slice(1), convertValue)
                    });
                }() : raise('malformed ..');
            }, convertValue(receiver));
        },
        'set!': function (v) {
            return ast('AssignmentExpression', {
                'operator': '=',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'aset!': function (v) {
            return ast('AssignmentExpression', {
                'operator': '=',
                'left': ast('MemberExpression', {
                    'computed': true,
                    'object': convertValue(v[1]),
                    'property': convertValue(v[2])
                }),
                'right': convertValue(v[3])
            });
        },
        '~': function (v) {
            raiseIf(!(v.length === 3), 'mailformed ~');
            return ast('MemberExpression', {
                'computed': true,
                'object': convertValue(v[1]),
                'property': convertValue(v[2])
            });
        },
        'new': function (v) {
            return ast('NewExpression', {
                'callee': convertValue(v[1]),
                'arguments': _.map(v.slice(2), convertValue)
            });
        },
        'array': function (v) {
            return ast('ArrayExpression', {'elements': _.map(v.slice(1), convertValue)});
        },
        '=': function (v) {
            raiseIf(!(v.length === 3), 'malformed =');
            return ast('BinaryExpression', {
                'operator': '===',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'if': function (v, isValueNeeded) {
            return isValueNeeded ? ast('ConditionalExpression', {
                'test': convertValue(v[1]),
                'consequent': convertValue(v[2]),
                'alternate': convertValue(v[3])
            }) : _.isUndefined(v[3]) ? ast('IfStatement', {
                'test': convertValue(v[1]),
                'consequent': convertStmt(v[2])
            }) : ast('IfStatement', {
                'test': convertValue(v[1]),
                'consequent': convertStmt(v[2]),
                'alternate': convertStmt(v[3])
            });
        },
        'begin': function (v, isValueNeeded) {
            return isValueNeeded ? ast('CallExpression', {
                'arguments': [],
                'callee': ast('FunctionExpression', {
                    'params': [],
                    'defaults': [],
                    'body': blockStmtWithReturn(v.slice(1)),
                    'id': null,
                    'rest': null,
                    'generator': false,
                    'expression': false
                })
            }) : ast('BlockStatement', {'body': _.map(v.slice(1), convertStmt)});
        },
        'and': function (v) {
            return ast('LogicalExpression', {
                'operator': '&&',
                'left': convertValue(v[1]),
                'right': convertValue(v[2])
            });
        },
        'or': function (v) {
            var rest = v.slice(1);
            return rest.length === 0 ? ast('Literal', {'value': false}) : rest.length === 1 ? ast('LogicalExpression', {
                'operator': '||',
                'left': convertValue(rest[0]),
                'right': ast('Literal', {'value': false})
            }) : _.reduce(rest.slice(1), function (acc, item) {
                return ast('LogicalExpression', {
                    'operator': '||',
                    'left': acc,
                    'right': convertValue(item)
                });
            }, convertValue(rest[0]));
        },
        'not': function (v) {
            raiseIf(!(v.length === 2), 'malformed not');
            return ast('UnaryExpression', {
                'operator': '!',
                'argument': convertValue(v[1])
            });
        },
        'while': function (v, isValueNeeded) {
            var whileStmt = ast('WhileStatement', {
                    'test': convertValue(v[1]),
                    'body': ast('BlockStatement', {'body': _.map(v.slice(2), convertStmt)})
                });
            return isValueNeeded ? wrapWithFunctionCall(whileStmt) : whileStmt;
        },
        'break': function (v) {
            return ast('BreakStatement', {'label': null});
        },
        'throw': function (v, isValueNeeded) {
            raiseIf(!(v.length === 2), 'malformed throw');
            var throwStmt = ast('ThrowStatement', {'argument': convertValue(v[1])});
            return isValueNeeded ? wrapWithFunctionCall(throwStmt) : throwStmt;
        },
        'raw-js-ast': function (v) {
            raiseIf(!(v.length === 2), 'malformed raw-js-ast');
            return v[1];
        }
    };
_.each([
    '+',
    '-',
    '*',
    '/'
], function (op) {
    return syntaxes[op] = function (v) {
        return ast('BinaryExpression', {
            'operator': op,
            'left': convertValue(v[1]),
            'right': convertValue(v[2])
        });
    };
})
var convertValue = function (v) {
    return convertNode(v, true);
};
var convertNode = function (v, isValueNeeded) {
    return _.isNumber(v) || _.isString(v) || _.isRegExp(v) || _.isBoolean(v) || _.isNull(v) ? ast('Literal', {'value': v}) : _.isUndefined(v) ? ast('UnaryExpression', {
        'operator': 'void',
        'argument': ast('Literal', {'value': 0})
    }) : _.isEmpty(v) ? ast('ObjectExpression', {'properties': []}) : isSymbol(v) ? ast('Identifier', {'name': v.jsName}) : _.isArray(v) ? function () {
        var first = v[0];
        var rest = v.slice(1);
        var conv = isSymbol(first) && syntaxes[first.name];
        return conv ? conv(v, isValueNeeded) : ast('CallExpression', {
            'callee': convertValue(v[0]),
            'arguments': rest.map(convertValue)
        });
    }() : ast('ObjectExpression', {'properties': _.map(_.pairs(v), function (pair) {
            return ast('Property', {
                'kind': 'init',
                'key': ast('Literal', {'value': pair[0]}),
                'value': convertValue(pair[1])
            });
        })});
};
var expandQq = function (a) {
    return !_.isArray(a) ? a : cons(Sym('append'), a.map(function (x) {
        return x[0] === Sym('quasiquote') ? raise('Nested quasiquote is not supported yet') : x[0] === Sym('unquote') ? [
            Sym('array'),
            x[1]
        ] : x[0] === Sym('unquote-splicing') ? x[1] : isSymbol(x) ? [
            Sym('array'),
            [
                Sym('quote'),
                x
            ]
        ] : _.isArray(x) ? expandQq(a) : x;
    }));
};
var quote = function (a) {
    return isSymbol(a) ? [
        Sym('Sym'),
        a.name
    ] : _.isArray(a) ? cons(Sym('array'), a.map(quote)) : a;
};
var macros = {
        'quote': function (v) {
            raiseIf(!(v.length === 2), 'malformed quote');
            return quote(v[1]);
        },
        'instance?': function (v) {
            raiseIf(!(v.length === 3), 'malformed instance?');
            return [
                Sym('raw-js-ast'),
                ast('BinaryExpression', {
                    'operator': 'instanceof',
                    'left': translateExpr(v[1]),
                    'right': translateExpr(v[2])
                })
            ];
        },
        'when': function (v) {
            return [
                Sym('if'),
                v[1],
                cons(Sym('begin'), v.slice(2)),
                undefined
            ];
        },
        'quasiquote': function (v) {
            raiseIf(!(v.length === 2), 'malformed quasiquote');
            return expandQq(v[1]);
        }
    };
var expandMacros = function (v, mod) {
    mod || (mod = new Object());
    var expandInner = function (x) {
        return expandMacros(x, mod);
    };
    return _.isArray(v) ? function () {
        var car = v[0];
        return isSymbol(car) ? syntaxes[car.name] ? _.contains([
            Sym('define'),
            Sym('^'),
            Sym('set!'),
            Sym('aset!')
        ], car) ? append(v.slice(0, 2), _.map(v.slice(2), expandInner)) : _.contains([
            Sym('throw'),
            Sym('not'),
            Sym('and'),
            Sym('or'),
            Sym('~'),
            Sym('new'),
            Sym('array'),
            Sym('='),
            Sym('if'),
            Sym('begin'),
            Sym('while')
        ], car) ? v.map(expandInner) : Sym('..') === car ? append([
            Sym('..'),
            expandMacros(v[1], mod)
        ], _.map(v.slice(2), function (c) {
            return isSymbol(c) ? expandMacros(c, mod) : _.isArray(c) ? cons(c[0], _.map(c.slice(1), expandInner)) : raise('malformed ..');
        })) : v : function () {
            var macro = macros[car.name];
            return macro ? function () {
                mod['modified'] = true;
                var ret = macro(v);
                while (true) {
                    var _mod = new Object();
                    ret = expandMacros(ret, _mod);
                    if (!_mod.modified) {
                        break;
                    }
                }
                return ret;
            }() : v.map(expandInner);
        }() : v.map(expandInner);
    }() : v;
};
var debug = false;
var translateExpr = function (expr) {
    if (debug) {
        d(expr);
    }
    var expanded = expandMacros(expr);
    if (debug) {
        d(expanded);
    }
    return convertNode(expanded);
};
var translate = function (exprs) {
    var ret = '// Generated by RumCoke ' + RUM_VERSION;
    exprs.forEach(function (expr) {
        var ast = translateExpr(expr);
        if (debug) {
            util.puts('ast: ' + util.inspect(ast, false, null, true));
        }
        return ret = ret + '\n' + escodegen.generate(ast);
    });
    return ret;
};
module.exports['translate'] = translate
module.exports['translateExpr'] = translateExpr
module.exports['expandMacros'] = expandMacros
